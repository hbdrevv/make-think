/**
 * Color Token Resolver
 *
 * Reads foundation.json, semantic-light.json, and semantic-dark.json
 * and generates a CSS file with all color custom properties.
 *
 * Usage:  node tokens/resolve-colors.mjs
 * Output: src/app/(frontend)/generated-tokens.css
 */
import { readFileSync, writeFileSync } from 'fs'
import { dirname, join } from 'path'
import { fileURLToPath } from 'url'

const __dirname = dirname(fileURLToPath(import.meta.url))

const foundation = JSON.parse(readFileSync(join(__dirname, 'foundation.json'), 'utf-8'))
const lightTokens = JSON.parse(
  readFileSync(join(__dirname, 'color/semantic-light.json'), 'utf-8'),
)
const darkTokens = JSON.parse(
  readFileSync(join(__dirname, 'color/semantic-dark.json'), 'utf-8'),
)

const warnings = []

// ── Flatten primitives ──────────────────────────────────────────
// Builds: { 'sage': '#DDE2D9', 'flame.200': '#F75828', ... }
function flattenPrimitives(obj, prefix = '') {
  const result = {}
  for (const [key, val] of Object.entries(obj)) {
    const path = prefix ? `${prefix}.${key}` : key
    if (val && typeof val === 'object' && 'value' in val) {
      result[path] = val.value
    } else if (val && typeof val === 'object') {
      Object.assign(result, flattenPrimitives(val, path))
    }
  }
  return result
}

const primitives = flattenPrimitives(foundation.primitive)

// ── CSS variable name helpers ───────────────────────────────────
// 'sage' → '--color-sage', 'flame.200' → '--color-flame-200'
function primitiveToCssVar(name) {
  return `--color-${name.replace(/\./g, '-')}`
}

// 'base' → '--surface-base', 'alt.base' → '--surface-alt-base'
function surfaceToCssVar(path) {
  return `--surface-${path.replace(/\./g, '-')}`
}

// ── Reference resolver ──────────────────────────────────────────
// Resolves token reference strings like '{primitive.sage}' to CSS var expressions
function resolveRef(refStr) {
  // Handle non-string values (gradient objects, etc.)
  if (typeof refStr !== 'string') return String(refStr)

  // Replace all {primitive.*} references
  let result = refStr.replace(/\{primitive\.([^}]+)\}/g, (match, name) => {
    if (name in primitives) {
      const val = primitives[name]
      // If the primitive value itself contains references (e.g. gradient),
      // resolve it inline rather than referencing a CSS var
      if (typeof val === 'string' && val.includes('{')) {
        return resolveRef(val)
      }
      return `var(${primitiveToCssVar(name)})`
    }
    // Try stripping suffix for fuzzy match (e.g. 'cashmere-light' → 'cashmere')
    const base = name.replace(/-[^.]+$/, '')
    if (base !== name && base in primitives) {
      warnings.push(`Unknown primitive: ${name} (falling back to ${base})`)
      return `var(${primitiveToCssVar(base)})`
    }
    warnings.push(`Unknown primitive: ${name} (no fallback found)`)
    return match
  })

  // Replace {color.surface.*} self-references
  result = result.replace(/\{color\.surface\.([^}]+)\}/g, (match, path) => {
    return `var(${surfaceToCssVar(path)})`
  })

  // Replace {foundation.shadow}
  result = result.replace(/\{foundation\.shadow\}/g, () => {
    const s = foundation.foundation?.shadow?.value
    if (s && typeof s === 'object') {
      return `${s.x}px ${s.y}px ${s.blur}px ${s.spread}px ${s.color}`
    }
    return '0 4px 4px 0 rgba(37,19,53,0.1)'
  })

  return result
}

// ── Flatten surface tokens ──────────────────────────────────────
// Walks color.surface tree and returns [['base', resolved], ['foreground', resolved], ...]
function flattenSurface(surfaceObj, prefix = '') {
  const entries = []
  for (const [key, val] of Object.entries(surfaceObj)) {
    const path = prefix ? `${prefix}.${key}` : key
    if (val && typeof val === 'object' && 'value' in val) {
      entries.push([path, resolveRef(val.value)])
    } else if (val && typeof val === 'object') {
      entries.push(...flattenSurface(val, path))
    }
  }
  return entries
}

// ── Build CSS ───────────────────────────────────────────────────
const lines = []
lines.push('/* Auto-generated by tokens/resolve-colors.mjs — do not edit */')
lines.push('')

// :root block
lines.push(':root {')

// Primitives
lines.push('  /* ===== PRIMITIVE COLORS ===== */')
for (const [name, hex] of Object.entries(primitives)) {
  // Skip gradient entries (they are composite values, not simple hex)
  if (typeof hex === 'string' && !hex.includes('linear-gradient') && !hex.includes('{')) {
    lines.push(`  ${primitiveToCssVar(name)}: ${hex};`)
  }
}
lines.push('')

// Light surface system
lines.push('  /* ===== SURFACE SYSTEM (LIGHT) ===== */')
const lightSurface = flattenSurface(lightTokens.color.surface)
for (const [path, value] of lightSurface) {
  lines.push(`  ${surfaceToCssVar(path)}: ${value};`)
}
lines.push('')

// Legacy aliases
lines.push('  /* ===== LEGACY ALIASES ===== */')
lines.push('  --background: var(--surface-base);')
lines.push('  --foreground: var(--surface-foreground);')
lines.push('  --card: var(--surface-elevated-base);')
lines.push('  --card-foreground: var(--surface-elevated-foreground);')
lines.push('  --popover: var(--surface-overlay-base);')
lines.push('  --popover-foreground: var(--surface-overlay-foreground);')
lines.push('  --primary: var(--surface-emphasis-base);')
lines.push('  --primary-foreground: var(--surface-emphasis-foreground);')
lines.push('  --secondary: var(--surface-alt-base);')
lines.push('  --secondary-foreground: var(--surface-alt-foreground);')
lines.push('  --muted: var(--surface-muted-base);')
lines.push('  --muted-foreground: var(--surface-muted-foreground);')
lines.push('  --accent: var(--surface-accent);')
lines.push('  --accent-foreground: var(--surface-foreground);')
lines.push('  --destructive: var(--color-flame-400);')
lines.push('  --destructive-foreground: var(--color-white);')
lines.push('  --border: var(--color-gray-300);')
lines.push('  --input: var(--surface-elevated-base);')
lines.push('  --ring: var(--surface-accent);')
lines.push('')

// Status colors
lines.push('  /* ===== STATUS COLORS ===== */')
lines.push('  --success: var(--color-sky-100);')
lines.push('  --warning: var(--color-flame-100);')
lines.push('  --error: var(--color-flame-400);')
lines.push('')

// Misc
lines.push('  /* ===== MISC ===== */')
lines.push('  --radius: 0.2rem;')

// Shadow from foundation
const shadow = foundation.foundation?.shadow?.value
if (shadow && typeof shadow === 'object') {
  // Format shadow values, using '0' instead of '0px' for zero values
  const fmt = (v) => (v === '0' || v === 0 ? '0' : `${v}px`)
  lines.push(`  --shadow: ${fmt(shadow.x)} ${fmt(shadow.y)} ${fmt(shadow.blur)} ${fmt(shadow.spread)} ${shadow.color};`)
} else {
  lines.push('  --shadow: 0 4px 4px 0 rgba(37,19,53,0.1);')
}

lines.push('}')
lines.push('')

// Dark theme
lines.push("[data-theme='dark'] {")
lines.push('  /* ===== SURFACE SYSTEM (DARK) ===== */')
const darkSurface = flattenSurface(darkTokens.color.surface)
for (const [path, value] of darkSurface) {
  lines.push(`  ${surfaceToCssVar(path)}: ${value};`)
}
lines.push('')
lines.push('  /* ===== LEGACY OVERRIDES ===== */')
lines.push('  --border: var(--color-gray-700);')
lines.push('  --input: var(--surface-elevated-base);')
lines.push('  --ring: var(--surface-accent);')
lines.push('')
lines.push('  --success: var(--color-sky-300);')
lines.push('  --warning: var(--color-flame-200);')
lines.push('  --error: var(--color-flame-400);')
lines.push('}')
lines.push('')

// Surface-level overrides (auto-generated from surface variant names)
lines.push('/* ===== SURFACE LEVEL OVERRIDES ===== */')
const surfaceVariants = ['alt', 'overlay', 'elevated', 'emphasis', 'muted', 'contrast']
for (const variant of surfaceVariants) {
  lines.push(`[data-surface='${variant}'] {`)
  lines.push(`  --surface-base: var(--surface-${variant}-base);`)
  lines.push(`  --surface-foreground: var(--surface-${variant}-foreground);`)
  lines.push(`  --surface-accent: var(--surface-${variant}-accent);`)
  lines.push(`  --background: var(--surface-${variant}-base);`)
  lines.push(`  --foreground: var(--surface-${variant}-foreground);`)
  lines.push('}')
  if (variant !== surfaceVariants[surfaceVariants.length - 1]) lines.push('')
}

lines.push('')

// Write output
const outPath = join(__dirname, '..', 'src', 'app', '(frontend)', 'generated-tokens.css')
writeFileSync(outPath, lines.join('\n') + '\n')

// Report
console.log(`✓ Generated ${outPath}`)
if (warnings.length) {
  for (const w of warnings) console.warn(`⚠ ${w}`)
}
